(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{411:function(a,s,v){"use strict";v.r(s);var t=v(17),_=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"linux下的as汇编器和nasm汇编器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux下的as汇编器和nasm汇编器"}},[a._v("#")]),a._v(" Linux下的as汇编器和NASM汇编器")]),a._v(" "),s("h2",{attrs:{id:"两者比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两者比较"}},[a._v("#")]),a._v(" 两者比较")]),a._v(" "),s("p",[a._v("Linux下的as汇编器和NASM汇编器在功能和使用上有一些异同。")]),a._v(" "),s("p",[a._v("相同点：")]),a._v(" "),s("ul",[s("li",[s("p",[s("strong",[a._v("汇编功能")]),a._v("：两者都是汇编器，用于将汇编语言源代码转换成机器码。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("跨平台性")]),a._v("：as和NASM都支持在Linux操作系统上运行，使得在Linux环境下进行汇编语言编程成为可能。"),s("br"),a._v("\n不同点：")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("语法支持")]),a._v("：as汇编器主要使用AT&T语法，而NASM则支持Intel语法。这两种语法在寄存器和指令的表示方式上有所不同，例如，在AT&T语法中，寄存器前需要加百分号%，而NASM则不需要。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("功能特性")]),a._v("：NASM具有更丰富的功能特性。例如，它支持多种输出格式，如ELF、COFF、OMF等，这使得程序可以重定向到任何x86架构的操作系统。此外，NASM还提供了一个强大的预处理器，类似于C/C++的预处理器功能，允许宏定义、条件编译等高级特性。而as汇编器虽然也具有一定的预处理能力，如删除多余的空格和制表符、删除注释等，但相比之下功能较为简单。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("兼容性和模块化")]),a._v("：NASM的设计初衷是为了提供一种可移植性与模块化的汇编工具，它不仅支持标准的x86和x64指令集，还支持多种扩展指令集，如MMX、SSE、AVX等。这使得NASM在编写复杂和高效的程序时具有更大的灵活性。as汇编器在兼容性方面可能稍逊于NASM，但它仍然能满足大多数基本的汇编需求。"),s("br"),a._v("\n总的来说，Linux下的as汇编器和NASM汇编器在功能和使用上各有特点。选择使用哪一个汇编器，主要取决于具体需求和编程环境。如果更习惯使用Intel语法或需要更强大的预处理和兼容性功能，那么NASM可能是一个更好的选择。而如果更偏向于AT&T语法或只需要基本的汇编功能，那么as汇编器可能更适合。")])])]),a._v(" "),s("h2",{attrs:{id:"as汇编器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#as汇编器"}},[a._v("#")]),a._v(" as汇编器")]),a._v(" "),s("h2",{attrs:{id:"nasm汇编器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nasm汇编器"}},[a._v("#")]),a._v(" nasm汇编器")]),a._v(" "),s("p",[a._v("编译汇编代码：")]),a._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[a._v("nasm "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-f")]),a._v(" elf64 "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-g")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-F")]),a._v(" stabs hello_asm.asm\n")])])]),s("p",[a._v("上面命令中：")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("nasm")]),a._v("是汇编器")]),a._v(" "),s("li",[s("code",[a._v("-f elf64")]),a._v("指定"),s("code",[a._v(".o")]),a._v("文件以"),s("code",[a._v("elf64")]),a._v("格式生成")]),a._v(" "),s("li",[s("code",[a._v("-g")]),a._v("指定调试信息被包含在"),s("code",[a._v(".o")]),a._v("文件中")]),a._v(" "),s("li",[s("code",[a._v("-F stabs")]),a._v("指定调试信息即将按照"),s("code",[a._v("stabs")]),a._v("格式产生")]),a._v(" "),s("li",[s("code",[a._v("hello_asm.asm")]),a._v("汇编文件的名称")])]),a._v(" "),s("p",[a._v("链接目标文件：")]),a._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[a._v("ld "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-o")]),a._v(" ha hello_asm.o\n")])])])])}),[],!1,null,null,null);s.default=_.exports}}]);